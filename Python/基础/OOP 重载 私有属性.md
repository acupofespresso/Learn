## 属性继承搜索
### object.attribute
* 当对class语句产生的对象使用这种方式时，会在Python中搜索对象链接的树，来寻找attribute首次出现的对象。
* 先搜索object，然后是该对象之上的所有类，由下至上，由左至右。
* 取出属性会对树进行搜索，这种搜索程序称为继承，树中位置较低的对象继承树中位置较高的对象拥有的属性。当从下至上搜索时，连接至树中的对象就是树中所有上层对象所定义的所有属性的集合体，直到树的最顶端。
* 树中位置较高的称为**超类(superclass)/基类(base class)**。
* 树中位置较低的类称为**子类/派生类(derived class)**。
    ```python
    class C2:#基类
    class C3:
    class C1(C2,C3):#派生类 多重继承
    I1 = C1()#创建实例
    ```
* 超类提供所有子类共享的行为。
* 因搜索是由下而上的，子类可能会在树中较低位置重新定义超类的变量名，从而覆盖超类定义的行为。

#### Python没有私有属性,采用名字重整方式实现
可在名称前，添加前缀 `__`（两个下划线），用来标识不应在外部访问该方法/属性  
##### 名字重整
可通过在开头添加一个下划线加类名调用  
```python
class test:
    def __init__(self,name):
        self.__name = name
t = test('红红')
print(t._test__name)
```

### 多重继承
1. 如多个超类中，存在同名方法，则位于前面的方法会覆盖后面的方法。
2. 多个超类的超类相同时，查找特定方法或属性时，访问超类的顺序称为**方法解析顺序（MRO）**。


### 运算符重载
* 运算符重载就是让用类写成的对象，可截获并响应，用在内置类型上的运算：加法、切片、打印、点号运算等。
* 运算符重载是表达式对方法的分发机制，可以在类对象中以任何喜欢的方式解释运算符。
* 自动分发机制：表达式和其他内置运算流程要经过类的实现来控制。
* 与模块不同：模块可以实现函数调用，而不是表达式行为。
* `__init__`：初始化构造函数
    1. 在类创建实例时，为实例添加初始化属性
    2. 构造时，Python使用继承来查找并调用唯一的一个`__init__`方法（类树中最低的一个）可通过超类名称，手动调用类树中更高的`__init__`方法
* `__add__`：加法（+）
* `__str__`：打印（print）
    1. 打印对象时，`__str__`会自动运行，会打印`__str__`返回的内容  
    2. 如没有`__str__`，则在打印实例对象，会显示对象的类名，及其在内存中的地址

## 类字典
### `__dict__`
类字典  
`res.__dict__.keys()`  
显示所有赋过值的属性  

### `__class__`
查看实例的类连接

### `__bases__`
查看基类的元组

## 抽象基类
模块**abc**，为抽象类提供了支持。  
抽象类不能被实例化。  
抽象类的职责是定义子类应实现的一组抽象方法，而不应该是实例化的类。  

